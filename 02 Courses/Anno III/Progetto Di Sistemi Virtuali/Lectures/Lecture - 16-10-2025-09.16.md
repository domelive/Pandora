---
date: 2025-10-16 09.16
course: 02 Courses/Anno III/Progetto Di Sistemi Virtuali/Lectures
tags:
  - lecture
  - "#sockets"
reviewed: false
last_reviewed:
next_review:
---
## üß† Concetti
---
#### Sockets
+ Nascono dall'universit√† di Berkeley, vicino San Francisco.
	+ Si pongono la domanda: Come facciamo a comunicare attraverso la rete.
+ √à un _interfaccia per comunicazione generale_, e non solamente per TCP/IP.
	+ Oggi lo si adopera anche per Bluetooth o AX25 (radio) e anche altro.
+ Occorre un elemento per poter _individuare il singolo flusso di comunicazione_.
	+ L'oggetto che viene creato per gestire una comunicazione avr√† la stessa natura dell'oggetto che viene creato quando si fa una `open` su UNIX.
+ Occorre individuare _l'interlocutore_ all'interno della rete.
	+ Si crea cos√¨ l'indirizzo di socket.
	+ Ci sono indirizzi di socket per ogni tipo di comunicazione.
+ Chiamate:
	+ `socket(int domain, int type, int protocol)`: crea un socket, ovvero un endpoint per una comunicazione.
		+ `domain`: tipo di rete al quale vogliamo collegarci.
			+ `AF_UNIX | AF_LOCAL`: flag per comunicazione locale.
			+ `AF_INET`: comunicazione con IPv4.
			+ `AF_NETLINK`: protocollo che serve per configurare gli stack di rete. (importante a quanto pare).
		+ `type`: indica all'interno della famiglia (dominio) il tipo di comunicazione che si vuole avere.
			+ `SOCK_STREAM`: la comunicazione non √® suddivisa in pacchetti nella visione dell'utilizzatore.
				+ Se spediamo 3 dati in 3 send diverse, e dall'altra parte si fa un receive, il buffer destinatario vede direttamente tutti e 3 i dati mandati.
				+ Se √® stata spedita una sequenza di caratteri, verr√† ricevuta la stessa sequenza o una sotto-sequenza iniziale degli stessi caratteri.
				+ Affidabile fino ad una certa.
					+ Se qualcosa va storto non √® detto che arrivi tutto quello che si invia.
				+ Se un pacchetto viene perso, perde tempo a ricostruire la sequenza.
			+ `SOCK_DGRAM`: la comunicazione avviene a pacchetti e non c'√® sicurezza che i pacchetti vengano recapitati nello stesso ordine, e non c'√® certezza che tutti vengano recapitati.
				+ Posso permettermi di perdere dei pacchetti.
				+ Ad esempio nello streaming video o nelle comunicazione per le quali basta un solo pacchetto.
					+ Ad esempio il DNS.
			+ `SOCK_SEQPACKET`: a datagrammi ma sequenziale e affidabile.
				+ I pacchetti arrivano in ordine e arriva sempre o l'intera sequenza o un prefisso di essa.
			+ `SOCK_RAW`: accesso in maniera grezza.
				+ Accesso a livello pi√π basso.
			+ `SOCK_NONBLOCK`: fa una lettura da file in cui se non ci sono dati da leggere ritorna 0 (successo).
			+ `SOCK_CLOEXEC`: se il file √® aperto al momento di una `exec` il file viene immediatamente chiuso.
		+ L'oggetto restituito da questa chiamata √® un _file descriptor_.
			+ √à possibile prendere dei programmi funzionanti con file normali e si possono usare con i socket.
			+ Ad esempio se mettiamo in pipe due comandi e abbiamo un socket stream, possiamo ridirezionare l'output di un comando su uno stream e lanciare il codice senza cambiare nulla.
				+ Il programma far√† la `write` sul socket.
	+ `bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen)`: serve per dare un nome (identificare) al (il) socket, dare un indirizzo.
		+ `sockaddr`: struttura diversa per ogni famiglia di protocolli.
			+ Primo campo √® sempre la famiglia, poi cambia in base ai protocolli.
		+ Se vogliamo una comunicazione P2P, basta che tutti e due i socket facciano `bind`.
			+ Devo conoscere l'indirizzo dall'altro lato.
		+ Se vogliamo una comunicazione Client-Server entrano in ballo le altre chiamate spiegate sotto.
	+ `listen(int sockfd, int backlog)`: lato server - fa in modo che il socket entri in ascolto di `connect()` da fuori.
		+ `backlog` serve per dimensionare il vettore per l'attesa.
			+ Indica quante connessioni in sospeso riusciamo a tollerare.
			+ Piccolo rimedio agli attacchi DoS.
	+ `connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen)`: lato client - come la bind ma bisogna mettere l'indirizzo dell'altro.
	+ `accept(int sockfd, struct sockaddr* _Nullable restrict addr, socklen_t* _Nullable restrict addrlen)`: lato server - prende il socket di accesso, e quando uno fa la `connect` questa funzione crea un file descriptor che serve per quella connessione.
		+ Ritorna il file descriptor che ci consente di parlare con quello specifico interlocutore.
		+ Possiamo creare un figlio con `fork` che gestisce la connessione tra due interlocutori, e poi il padre si occupa di chiudere la connessione fra i due e far ripartire il ciclo per accettare una nuova connessione.
	+ `recv() / send() / sendto() / recvfrom()`: essendo un file descriptor, possiamo fare delle syscall come se fossero dei device.
	+ `sendmsg() / recvmsg()`: consentono di mandare/ricevere non da un buffer ma da molteplici buffer.
		+ Ad esempio, se devo inviare un messaggio composto da vari sotto-messaggi, posso usare la `sendmsg()` dicendo la lunghezza e come sono composti i vari pacchetti.
+ `strace`: fa vedere tutte le syscall che vengono chiamate in un programma.
+ Per IoTh, esiste la `ioth_socket()`.
## ‚ùì Domande
---

## üí° Riferimenti
---

## üß© Tasks
---
+ [ ] Review [[Lecture - 16-10-2025-09.16]]

```button 
name ‚úÖ Mark [[Lecture - 16-10-2025-09.16]] As Reviewed 
type command 
action QuickAdd: Mark As Reviewed
```
