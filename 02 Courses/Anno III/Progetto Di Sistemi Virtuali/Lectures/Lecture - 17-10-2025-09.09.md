---
date: 2025-10-17 09.09
course: 02 Courses/Anno III/Progetto Di Sistemi Virtuali/Lectures
tags:
  - lecture
  - "#vuos"
  - "#ioth"
reviewed: false
last_reviewed:
next_review:
---
## üß† Concetti
---
#### `vudev`: Device Virtuali
+ _Device_
	+ I device sono dei file speciali, che di solito si trovano nella directory `/dev`.
		+ Sono solamente dei 'simulacri/rimandi'.
		+ Se guardiamo un file nella directory c'√® solamente l'i-node.
			+ Esso contiene solamente due numeri, al posto della lunghezza del file:
				+ _Major number_: individua il device o il driver.
				+ _Minor number_: individua una precisazione all'interno del major number.
			+ Quando facciamo la `open` di un file in `/dev`, il kernel per capire quale sia effettivamente il device guarda i due numeri.
				+ Servono per mettersi d'accordo tra processo utente e kernel.
		+ Questa directory √® un filesystem virtuale, in modo che se carichiamo un nuovo device compare magicamente il driver.
+ Per virtualizzare un device occorre:
	+ Virtualizzare le syscall normali come `read / open`.
	+ In pi√π bisogna virtualizzare la syscall `ioctl`.
		+ Ogni driver ha i suoi comandi di `ioctl` e le sue funzionalit√†.
		+ `ioctl` ha 3 parametri 
			1. File descriptor.
			2. Funzione che dice cosa fare.
			3. Dipende dal primo e dal secondo.
	+ Su `umvu` bisogna fare:
		+ `vu_insmod vudev fuse`.
			+ `fuse`: filesystem in spazio utente.
				+ Servizio che pu√≤ essere caricato nel server.
				+ Consente agli utenti di caricare filesystem.
					+ Possono caricare delle immagini di filesystem come utenti ma il servizio √® fornito dal kernel.
				+ Virtualizza il device in `/dev/fuse` e fa in modo che gli utenti possano caricare filesystem creando un maggior livello di sicurezza.
				+ Esiste il comando `fusemount` per montare il filesystem.
					+ Quando il processo lancia questo comando diventa `root`, mettendo un livello di pericolosit√† in pi√π.
					+ Se lo usiamo in `umvu` per√≤ non √® pericoloso, in quanto le chiamate passano per il layer virtuale di `umvu` e non si rischia nulla.
				+ Per caricare filesystem `ext` si usa `fuse2fs` per caricare filesystem fat si usa `fusefatfs`, che per√≤ √® un modulo di virtual square.
		+ `vumount -t vudevramdisk -o size=10M none /dev/ramdisk`.
			+ Se a questo punto lanciamo `stat /dev/ramdisk` possiamo vedere il device che √® stato creato.
			+ Abbiamo un pezzo di memoria che viene rappresentato come un disco.
			+ Lanciando `/sbin/mkfs.ext4 /dev/ramdisk` andiamo a creare una struttura di filesystem dentro il file `/dev/ramdisk.
		+ A questo punto la macchina vera non pu√≤ vedere il disco che abbiamo appena creato.
			+ Il disco creato con `umvu` gestisce tutte le syscall senza richiamare direttamente il kernel.
#### `vudevpartx`: Per Partizioni Del Disco
+ Se vediamo un disco, esso pu√≤ avere diverse partizioni.
	+ Ad esempio un raspberry-pi ha due partizioni.
		+ Una fat per il boot.
		+ Una per il `root` che √® un `ext4`.
+ Ci sono due modi per gestire le partizioni:
	+ Master Boot Record (MBR).
		+ Vecchia.
	+ Global Partition Table (GPT).
		+ Nuova.
		+ Per creare una GPT si lancia `/sbin/gdisk file`.
	+ `vudev` √® in grado di gestirle entrambe.
#### `vufs`: Filesystem Virtuale/Patch Working
+ Consente ad esempio di prendere un sotto-albero del filesystem e vederlo in un altro path.
	+ Quindi consente di spostare pezzi di filesystem o filesystem interi.
+ Esempio filesystem di base - vogliamo far vedere `/var` in `/mnt`:
	+ `vu_insmod vufs`.
	+ `vumount -f vufs /var /mnt`.
+ 4 modi di funzionamento:
	+ `bind`: collega questo a quello.
		+ Esempio di prima.
	+ `merge`: date due directory vogliamo fare comparire l'unione delle due directory.
		+ Se ci sono due file con lo stesso nome prende quello montato.
	+ `cow`: stessa cosa del merge, ma se facciamo delle modifiche esse vengono fatte sulla partizione che abbiamo montato.
		+ Se esiste un file e ne cambiamo il contenuto, esso viene copiato nella directory che montiamo in modo che non venga cambiato il contenuto in s√© ma si crea una copia.
	+ `mincow`: tutte le operazioni vengono fatte sul filesystem reale.
		+ Se non riesce a farle le fa `cow`.
#### `vunet`: Virtual Network
+ Abbiamo visto `vdens` in precedenza.
	+ Si ottengono namespace collegati alla rete con `slirp://`.
	+ Il namespace √® fatto dal kernel.
	+ `vunet` porta il namespace fuori dal kernel.
+ Ad esempio se vogliamo montare uno stack, si crea un device che rappresenta lo stack:
	+ `vu_insmod vunet`.
	+ `vumount -t vunetioth -o slirp::// vdestack /dev/net/x`.
		+ Siccome non esiste il tipo di file `stack`, viene categorizzato come `weird file`.
	+ Se adesso facessi: `vustack /dev/net/x ip addr` vedo l'altro stack.
	+ Se adesso facessi: `vustack /dev/net/x bash && ip addr` vedo comunque l'altro stack e si comporta come tale.
+ Invece di usare un namespace di un kernel lo si porta fuori dal kernel stesso.
	+ Assomigliano molto ai server dei vari servizi dei sistemi a micro-kernel.
		+ Ci sono due scuole di pensiero principali: monolitico e micro-kernel.
		+ `vuos` crea la gamma intermedia.
			+ Posso fare questo in maniera monolitica o a micro-kernel.
+ Se usiamo `IoTh` teniamo il programma invariato e possiamo farlo funzionare su implementazioni di stack diversi cambiando solamente una stringa.
#### Scriviamo Programmi C Che Devono Interfacciarsi Con La Rete (IoTh)
+ L'idea di internet of threads:
	+ Normalmente i processi che usano la rete in Linux utilizzano i Berkeley sockets e dialogano con lo stack che fa parte del codice del kernel.
		+ Alto livello: parla il socket.
		+ Basso livello: parla con `read / write` sul device che rappresenta l'interfaccia di rete.
	+ Possiamo fare una libreria che non passi per il kernel.
		+ Stack virtuali devono parlare con reti virtuali.
			+ Ci deve comunque essere un tipo di accesso alla rete fisica.
		+ Si ha il networking completamente fuori dal kernel.
		+ L'applicazione carica lo stack come libreria e si interfaccia tramite `vdeplug` con reti `vde`.
+ L'applicazione si scrive con la libreria `libioth` e mettendo una stringa andiamo a cambiare il tipo dell'implementazione del networking del kernel.
	+ Possiamo scrivere un web server con `libioth` e cambiando quella stringa il web server funziona ugualmente ma con un'implementazione dello stack diversa.
#### `newstack`: Stack Di Rete IoTh
+ Abbiamo uno stack di rete e per poter dialogare ha bisogno di almeno un'interfaccia.
+ `struct ioth* ioth_newstack(const char* stack, const char* vn1);`.
	+ `stack`: stringa dello stack.
	+ `vn1`: rete virtuale a cui vogliamo connetterla.
#### `msocket`: Socket IoTh
+ `ioth_msocket(...)`: estensione del socket.
	+ Per tutto il resto di usano i socket normali. (reference a MasterCard)
+ _Manca un pezzo_: non esistono funzioni per dire che voglio cambiare l'indirizzo IP.
	+ Sono state fatte due librerie per due scopi diversi.
		+ Per cambiare l'indirizzo IP il comando deve parlare con il kernel per alcune syscall.
			+ `ifconfig`: deprecato in quanto utilizza `ioctl` per parlare con il kernel, e poi non supporta IPv6.
			+ `ip addr`: nuovo comando.
				+ Lanciando `strace ip addr` possiamo vedere le syscall che vengono utilizzate per implementare il programma.
					+ Apre un socket per inizializzare il protocollo di configurazione delle reti, fa il bind e poi fa una send.
						+ `recvmsg`: si pu√≤ fare una receive dicendo di poter ricevere il primo pacchetto in ingresso lasciandolo in coda.
							+ Se non c'√® spazio troncalo. (?)
					+ Facendo la send manda il modo in cui √® fatto il pacchetto.
	+ La prima libreria `netinline` √® quella da usare nei programmi utente.
		+ Libreria fatta solo di macro.
			+ In questo modo non si deve compilare per tutte le architetture.
+ Come si accede un sistema remoto?
	+ Si conosce l'IP.
	+ Si fa un port scan per capire i servizi aperti.
	+ Mi sono distratto...
#### We Do V Better: Tools Che Sono Stati Virtualizzati Da Virtual Square
+ `fakeroot`: i processi che usano questo comando vengono visti come `root` anche se in realt√† non lo sono.
+ `chroot`: cambia la directory di `root` per il processo corrente e i suoi figli.

## ‚ùì Domande
---

## üí° Riferimenti
---

## üß© Tasks
---
+ [ ] Review [[Lecture - 17-10-2025-09.09]]

```button 
name ‚úÖ Mark [[Lecture - 17-10-2025-09.09]] As Reviewed 
type command 
action QuickAdd: Mark As Reviewed
```
