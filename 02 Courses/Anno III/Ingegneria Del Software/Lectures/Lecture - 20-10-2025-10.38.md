---
date: 2025-10-20 10.38
course: 02 Courses/Anno III/Ingegneria Del Software/Lectures
tags:
  - lecture
  - "#design_patterns"
reviewed: false
last_reviewed:
next_review:
---
## üß† Concetti
---
#### Composite
+ Esempio della directory, la quale √® un file che contiene altri file.
+ Nel nostro caso abbiamo una classe da cui deriva un'altra classe che contiene oggetti dello stesso tipo della classe padre.
+ Ho una struttura che contiene un insieme di altri oggetti.
+ Qualunque struttura che pu√≤ essere ricorsiva pu√≤ utilizzare questo design patterns.
#### Iterator
+ Permettono di scandire delle strutture attraverso delle iterazioni.
+ √à un'operazione che lavora su un oggetto o una classe concreta e fornisce le seguenti operazioni:
	+ `first()`.
	+ `next()`.
	+ `isDone()`.
	+ `currentItem()`.
+ √à un pattern comportamentale.
#### Builder - Creazionale
+ Quasi scompare nei linguaggi con il costruttore.
+ Delega la creazione dell'oggetto, che contiene altri oggetti, ad una classe chiamata direttore della costruzione.
	+ Esso tiene traccia di tutti gli oggetti che devono essere creati all'interno della classe stessa.
+ Un esempio √® il costruttore.
#### Abstract Factory - Creazionale
+ Ho a che fare con il problema di creare famiglie di oggetti coerenti e che dipendono da una scelta iniziale.
	+ Non voglio ogni volta di volermi occupare dell'implementazione concreta.
+ Problema tipico: interfacce grafiche.
	+ Devo fare in modo che tutti gli oggetti che vado a creare, devono essere per quella specifica interfaccia grafica.
	+ Tutti i widget devono corrispondere a quella interfaccia.
+ Ho tante famiglie di componenti.
	+ Ad esempio il men√π oppure un'etichetta su un titolo.
	+ Su ognuno di questi posso avere delle operazioni diverse.
+ Creo una abstract factory che mi gestisca tutti i componenti.
	+ Tutti questi componenti devono appartenere alla stessa famiglia.
	+ Non creo un componente con una `new` ma tramite una specifica operazione che ho implementato.
	+ Ho incapsulato il comportamento.
#### Factory - Creazionale
+ Applicazione ridotta della abstract factory.
+ Semplicemente non voglio andare a mettere la mani sul costruttore.
+ Contestualizzo la creazione del componente in un metodo e lo richiamo per costruire il componente.
+ Molte volte factory e singleton sono combinati insieme.
#### Prototype - Creazionale
+ Crea un oggetto copiando un oggetto esistente.
	+ A runtime posso non sapere qual √® la struttura dell'oggetto che devo utilizzare, ma voglio simularne un'altro.
	+ Genero un'oggetto identico a quello che gi√† avevo.
+ Ad esempio l'operazione `clone` in javascript.
+ Usato molto nelle interfacce grafiche.
	+ Ad esempio un programma che legge XML e ne crea la visualizzazione grafica.
	+ A runtime crea tutti i tipi, come ad esempio `bottone` o `etichetta` e poi li usa in un certo modo.
+ Reflection in `smalltalk`.
#### Adapter E Bridge - Strutturale
+ Usati per separare l'interfaccia di una classe dalla sua implementazione.
	+ Usato per risolvere il miss match dei nomi.
+ Adapter:
	+ Come una presa tedesca.
	+ Creo una funzione intermedia che mi mappa una chiamata a funzione ad un'altra funzione.
	+ Comunissimo nell'interfacciare i diversi LLM.
		+ Hanno endpoint che fanno a riferimento a definizioni generali, e ci metto un adapter sopra.
	+ Posso farlo anche senza ereditariet√† multipla utilizzando l'aggregazione.
+ Bridge:
	+ Serve per implementare la differenza tra l'interfaccia e l'implementazione.
	+ Una classe definisce delle operazioni.
	+ Poi ho una classe che implementa le operazioni.
#### Decorator - Strutturale
+ Oggetto di confusione.
	+ In python esiste il decorator che non ha nulla a che vedere con questo pattern.
+ Fa in modo che un'oggetto possa essere arricchito a piacere senza modificarne il comportamento.
+ Alternativa a fare sotto-classi all'infinito.
#### Proxy - Strutturale
+ Molto simile al bridge.
+ L'implementazione √® nascosta all'oggetto reale.
+ L'unica differenza √® che permette accessi remoti o virtuale.
+ Pu√≤ essere fatto a livello di classe o livello di oggetto.
	+ In Java la _remote method invocation compiler (RMIC)_ √® un'implementazione del proxy.
		+ Ogni classe ha una `.class` e non nasce con un eseguibile singolo.
		+ Queste classi si spargono su entit√† computazionali e la eseguo dove c'√® la situazione migliore.
	+ Noi non la facciamo mai perch√© dopo hanno inventato l'architettura a servizi.
#### Visitor - Comportamentale
+ Posso fare un'operazione su elementi di una struttura.
+ Permette di creare una nuova operazione senza cambiare gli elementi su cui opera, in quanto l'oggetto abilitato decide che operazione fare.
+ √à molto presente dove non ci sono template delle funzioni.
#### Strategy - Comportamentale
+ Simile al visitor.
+ Permette di parametrizzare oggetti con comportamenti multipli a runtime.
+ Utile quando ho pi√π classi che differiscono nel loro comportamento.
+ Ho una funzione di strategia che applico a seconda dell'oggetto che ho.
	+ Una cosa √® stampare una directory, un'altra cosa √® stampare un file.
#### Chain Of Responsibility - Comportamentale
+ Quando pi√π oggetti possono rispondere ad una richiesta.
+ Non so a priori quale oggetto mi dar√† la richiesta.
+ Gli oggetti vengono passati l'uno all'altro fino a quando non ricevo una richiesta da qualcuno.
	+ C'√® un ordine all'interno delle classi.
	+ Se la pi√π specifica ha la risposta alla mia richiesta allora la ricevo subito.
	+ Altrimenti la richiesta viene passata alle sottoclassi meno specifiche fino a che non ricevo una risposta.
#### Mediator - Comportamentale
+ Ero in bagno.
#### Architettura Software
+ Gli stili di architettura software possono trovare utilizzo in svariate applicazioni.
	+ Vengono definiti come una famiglia di sistemi in termini di un pattern di struttura organizzativa.
	+ Vengono usati per capire cosa sto facendo e cosa non dovrei fare.
+ Ci sono 7 categorie di stili architetturali:
	+ _Pipe E Filtri_: modo in cui passo le informazioni in linux e come funziona un compilatore.
		+ L'output di uno √® l'input di un altro.
		+ I filtri devono essere entit√† indipendenti.
			+ Non hanno necessit√† di conoscere cosa c'√® prima e cosa c'√® dopo.
	+ _Organizzazione Object Oriented_: organizzazione ad attori.
		+ Ogni oggetto √® un'entit√† che esegue un compito su una data macchina e trasmette il risultato ad altri oggetti che stanno su altre macchine.
		+ Entit√† dotate di capacit√† di esecuzione autonoma.
			+ Architetture peer-to-peer.
			+ Architetture robuste e sicure.
	+ _A Livelli_: come TCP/IP.
		+ Separo la visione ad alto livello da quella a basso livello.
		+ Pi√π facile programmare.
		+ Sistema rigido che pu√≤ penalizzare le performance.
	+ _Sistemi A Eventi_: esecuzione di un'operazione sulla base dell'arrivo di un evento.
		+ Il sistema aspetta che avvenga un evento per farlo funzionare.
		+ Struttura tipica dei sistemi reattivi.
		+ Sono implementate le applicazioni in Android e iOS.
	+ _Repositories_: basate su database.
		+ DB guida le operazioni. (?)
		+ Architettura blackboard:
			+ Sorgenti di informazione.
			+ Strutture dati.
			+ Controlli.
	+ _Interpreti_: modelli in cui il sistema √® cos√¨ complesso che non voglio risolvere il problema in se ma creo un interprete che lo risolva attraverso un sotto-programma.
		+ Mi interfaccio a questi modelli tramite un linguaggio particolare.
			+ Come SQL per i database.
		+ Di solito hanno un motore di interpretazione, una memoria e uno stato per gestire l'esecuzione.
	+ _Interpreti A Tabelle_: la tabella rappresenta lo stato.

## ‚ùì Domande
---

## üí° Riferimenti
---

## üß© Tasks
---
+ [ ] Riscrivere [[Lecture - 20-10-2025-10.38]]
+ [ ] Review [[Lecture - 20-10-2025-10.38]]

```button 
name ‚úÖ Mark [[Lecture - 20-10-2025-10.38]] As Reviewed 
type command 
action QuickAdd: Mark As Reviewed
```
